import { GoogleGenerativeAI } from "@google/generative-ai"
import { type NextRequest, NextResponse } from "next/server"

const GEMINI_API_KEY = process.env.GEMINI_API_KEY

const genAI = GEMINI_API_KEY ? new GoogleGenerativeAI(GEMINI_API_KEY) : null

const model = genAI?.getGenerativeModel({ model: "gemini-1.5-pro" })

export async function POST(req: NextRequest) {
  try {
    if (!model) {
      return NextResponse.json({
        success: false,
        message: "Gemini API key not configured.",
      })
    }

    const { description, productName, tone, style } = await req.json() // productName is not used in current prompt

    if (!description) {
      return NextResponse.json({
        success: false,
        message: "No description provided.",
      })
    }

    let prompt = `Improve the following product description to be more engaging and persuasive. Focus on highlighting the key benefits and features in a way that resonates with potential customers. Keep the tone professional and appealing.`
    if (productName) { // Though not in the original prompt, if provided, it could be useful
      prompt += ` The product is named "${productName}".`
    }
    prompt += `\nDescription: ${description}`

    if (tone) {
      prompt += `\n\nInstructions:\n- The tone of the description should be ${tone}.`
    }
    if (style) {
      prompt += `${tone ? "" : "\n\nInstructions:"}\n- The output style for the description should be primarily ${style}.`
    }
    // The Gemini model here is configured for JSON output, but the prompt doesn't ask for a specific JSON structure.
    // This might be problematic. The original prompt did not specify JSON output.
    // The previous code had `responseMimeType: "application/json"` but the prompt was not asking for JSON.
    // For now, I will keep `responseMimeType: "application/json"` but the prompt does not enforce a specific JSON structure.
    // This means the model might return plain text, or JSON, depending on its training.
    // The original code `const enhancedDescription = response.text()` suggests it was expecting text.

    const result = await model.generateContent({
      contents: [{ role: "user", parts: [{ text: prompt }] }],
      generationConfig: {
        temperature: 0.7,
        topK: 40,
        topP: 0.95,
        responseMimeType: "application/json",
      },
    })

    const response = result.response
    const textOutput = response.text()

    // Attempt to return a structure similar to the OpenAI endpoint for consistency,
    // but Gemini here is not explicitly asked to produce this JSON structure.
    // This part might need future refinement if Gemini doesn't naturally return compatible output.
    // For now, we'll assume the main output is the description, and context is generic.
    try {
      // Check if the output is already JSON
      const parsedJson = JSON.parse(textOutput)
      if (parsedJson.enhanced_description && parsedJson.generation_context) {
        return NextResponse.json({
          enhancedDescription: parsedJson.enhanced_description,
          generationContext: parsedJson.generation_context,
        })
      }
      // If it's JSON but not the expected structure, wrap it.
      return NextResponse.json({
        enhancedDescription: textOutput, // Or parsedJson if it's a simple string in JSON
        generationContext: "Description generated by Gemini.",
      })
    } catch (e) {
      // If not JSON, assume plain text
      return NextResponse.json({
        enhancedDescription: textOutput,
        generationContext: "Description generated by Gemini. Tone/style instructions were applied if provided.",
      })
    }
  } catch (error: any) {
    console.error("Error enhancing description with Gemini:", error)
    return NextResponse.json({ success: false, message: error.message })
  }
}
