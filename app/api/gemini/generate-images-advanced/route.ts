import { type NextRequest, NextResponse } from "next/server"
import type { ImagenGenerationOptions } from "../../../../services/providers/geminiImagenService"

const GOOGLE_API_KEY = process.env.GEMINI_API_KEY || process.env.GOOGLE_GEN_AI_API_KEY || process.env.API_KEY
const GOOGLE_PROJECT_ID = process.env.GOOGLE_PROJECT_ID
const GOOGLE_REGION = process.env.GOOGLE_REGION

// Using a specific Imagen 3 model ID for Vertex AI. Adjust if needed.
// Other options might include imagegeneration@007 or similar.
const MODEL_ID = "imagen-3.0-generate-preview-0619"

function mapAspectRatio(aspectRatio?: string): string {
  switch (aspectRatio) {
    case "ASPECT_RATIO_1_1":
      return "1:1"
    case "ASPECT_RATIO_9_16":
      return "9:16"
    case "ASPECT_RATIO_16_9":
      return "16:9"
    case "ASPECT_RATIO_4_3":
      return "4:3"
    case "ASPECT_RATIO_3_4":
      return "3:4"
    default:
      return "1:1"
  }
}

export async function POST(request: NextRequest) {
  if (!GOOGLE_API_KEY) {
    return NextResponse.json({ error: "Google API Key not configured on the server." }, { status: 500 })
  }
  if (!GOOGLE_PROJECT_ID || !GOOGLE_REGION) {
    return NextResponse.json({ error: "Google Project ID or Region not configured." }, { status: 500 })
  }

  try {
    const options: ImagenGenerationOptions = await request.json()

    if (!options.prompt) {
      return NextResponse.json({ error: "Missing required field: prompt" }, { status: 400 })
    }

    const {
      prompt,
      numberOfImages = 1,
      aspectRatio,
      // style, // Style is often part of the prompt for Vertex AI Imagen
      // quality, // Quality might be implicit or a different parameter
      seed,
      guidanceScale,
      // safetyLevel // Vertex AI has its own safety mechanisms
    } = options

    // Vertex AI expects a slightly different parameter structure
    const vertexParameters: Record<string, any> = {
      sampleCount: Math.min(Math.max(numberOfImages, 1), 4), // Clamp between 1 and 4
      aspectRatio: mapAspectRatio(aspectRatio),
    }
    if (seed) vertexParameters.seed = seed
    if (guidanceScale) vertexParameters.guidanceScale = guidanceScale
    // Add other parameters as supported by the model, e.g., quality, negativePrompt

    // Enhance prompt with style if provided
    const finalPrompt = options.style ? enhancePromptForStyle(prompt, options.style) : prompt

    const requestBody = {
      instances: [{ prompt: finalPrompt }],
      parameters: vertexParameters,
    }

    const endpoint = `https://${GOOGLE_REGION}-aiplatform.googleapis.com/v1/projects/${GOOGLE_PROJECT_ID}/locations/${GOOGLE_REGION}/publishers/google/models/${MODEL_ID}:predict`

    console.log(`Making request to Vertex AI Imagen API: ${endpoint} with prompt: "${finalPrompt}"`)

    const response = await fetch(endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        // For Vertex AI, Authorization is typically a Bearer token (OAuth2).
        // If your GOOGLE_API_KEY is a simple API key, it might need to be used differently
        // or the key needs specific permissions/setup to act as a Bearer token.
        // This setup assumes the API key can be used as a Bearer token for simplicity here.
        // In production, prefer service account keys for server-to-server auth.
        Authorization: `Bearer ${GOOGLE_API_KEY}`,
      },
      body: JSON.stringify(requestBody),
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error("Vertex AI Imagen API error:", response.status, errorText)
      let errorMessage = `Vertex AI Imagen API Error: ${response.status}`
      try {
        const errorData = JSON.parse(errorText)
        errorMessage = errorData.error?.message || errorMessage
      } catch (e) {
        // If parsing fails, use the raw text
        errorMessage = `${errorMessage} - ${errorText}`
      }
      return NextResponse.json({ error: errorMessage }, { status: response.status })
    }

    const data = await response.json()

    if (!data.predictions || data.predictions.length === 0) {
      console.error("No predictions in Vertex AI response:", data)
      return NextResponse.json({ error: "No images generated by Vertex AI Imagen API" }, { status: 500 })
    }

    // Images are typically base64 encoded in a field like 'bytesBase64Encoded'
    const images = data.predictions
      .map((pred: any) => {
        if (pred.bytesBase64Encoded) {
          return pred.bytesBase64Encoded
        }
        // Fallback for other possible field names, adjust as per actual model response
        if (pred.image_bytes) return pred.image_bytes
        console.warn("Unexpected prediction format:", pred)
        return null
      })
      .filter((img: string | null) => img !== null) as string[]

    if (images.length === 0) {
      console.error("No valid image data found in predictions:", data.predictions)
      return NextResponse.json({ error: "No valid image data in Vertex AI response" }, { status: 500 })
    }

    console.log(`Successfully generated ${images.length} images with Vertex AI Imagen`)

    return NextResponse.json({
      images,
      metadata: {
        prompt: finalPrompt,
        aspectRatio: vertexParameters.aspectRatio,
        // style: options.style, // Include if meaningful
        // quality: options.quality, // Include if meaningful
        modelVersion: MODEL_ID,
      },
    })
  } catch (error) {
    console.error("Error in Vertex AI Imagen generate-images API route:", error)
    const message = error instanceof Error ? error.message : "An unknown error occurred"
    return NextResponse.json({ error: message }, { status: 500 })
  }
}

// This function might need adjustment based on how Vertex AI Imagen handles styles
function enhancePromptForStyle(prompt: string, style?: string): string {
  if (!style) return prompt
  const styleEnhancements: Record<string, string> = {
    photographic: "professional photography, high resolution, detailed, realistic lighting",
    digital_art: "digital art, concept art, detailed illustration, vibrant colors",
    sketch: "pencil sketch, hand-drawn, artistic sketch, detailed line art",
    watercolor: "watercolor painting, soft colors, artistic, flowing paint effects",
    oil_painting: "oil painting, classical art style, rich textures, painterly",
    anime: "anime style, manga art, detailed character design, vibrant anime colors",
  }
  const enhancement = styleEnhancements[style]
  return enhancement ? `${prompt}, ${enhancement}` : prompt
}
